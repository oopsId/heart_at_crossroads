<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сердце на перекрёстке</title>
    <style>
        /* Стили остаются без изменений */
        @font-face {
            font-family: 'LobsterTwo';
            src: url('/heart_at_crossroads/assets/fonts/LobsterTwo-Bold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
        }
        @font-face {
            font-family: 'GreatVibes';
            src: url('/heart_at_crossroads/assets/fonts/GreatVibes-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'GoodVibesCyr';
            src: url('/heart_at_crossroads/assets/fonts/GoodVibesCyr.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #000;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            max-width: 100vw;
            max-height: 100vh;
        }
        .parallax-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: 0% center;
            background-repeat: no-repeat;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            animation: slideBackground 60s linear infinite;
            z-index: 1;
            transition: opacity 1s ease;
        }
        @keyframes slideBackground {
            0% { background-position: 0% center; }
            50% { background-position: 100% center; }
            100% { background-position: 0% center; }
        }
        .character-left, .character-right {
            position: absolute;
            bottom: 0;
            width: 70%;
            max-width: 100vw;
            height: 100vh;
            max-height: 100vh;
            background-position: bottom center;
            background-size: contain;
            background-repeat: no-repeat;
            z-index: 2;
            transition: opacity 1s ease, transform 0.3s ease, filter 0.3s ease;
            animation: appear 0.5s ease-in-out forwards;
        }
        @keyframes appear {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        @keyframes shiver {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        .shiver {
            animation: shiver 0.5s infinite;
        }
        .heartbeat {
            animation: heartbeat 1s 3;
        }
        .character-left { left: -15%; transform: translateX(0); }
        .character-right { right: -15%; transform: translateX(0); }
        .character-speaker {
            transform: scale(1.1);
            filter: brightness(1.2);
            z-index: 3;
        }
        .character-non-speaker {
            transform: scale(1);
            filter: brightness(1);
            z-index: 2;
        }
        .dialogue-box {
            position: absolute;
            bottom: 20%;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(93, 64, 55, 0.8), rgba(93, 64, 55, 0.4));
            color: #F5F0E1;
            padding: 2px 20px 20px;
            text-align: center;
            z-index: 3;
            transition: opacity 1s ease, bottom 0.3s ease;
            opacity: 1;
            min-height: 150px;
            max-height: 50vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            box-sizing: border-box;
        }
        #speaker-name {
            margin: 0;
            font-size: 18px;
            font-weight: bold;
            color: #E6D5C0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        #dialogue-text {
            margin: 5px 0;
            font-size: 16px;
            line-height: 1.4;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        .choice-btn {
            display: block;
            margin: 10px auto;
            padding: 10px;
            width: 90%;
            background: linear-gradient(to bottom, #F5F0E1, #E6D5C0);
            color: #5D4037;
            border: 1px solid rgba(93, 64, 55, 0.2);
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            white-space: normal;
            min-height: 44px;
            height: auto;
            overflow: hidden;
            text-overflow: ellipsis;
            box-shadow: 0 2px 5px rgba(93, 64, 55, 0.3);
        }
        .choice-btn:disabled {
            background: linear-gradient(to bottom, #666, #555);
            opacity: 0.7;
            box-shadow: none;
        }
        .choice-btn:hover:not(:disabled) {
            background: linear-gradient(to bottom, #E6D5C0, #D4BEA6);
            box-shadow: 0 3px 7px rgba(93, 64, 55, 0.4);
        }
        #menu {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 4;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-end;
            max-width: calc(100% - 20px);
            overflow-x: auto;
            white-space: nowrap;
        }
        #menu div {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        #menu img {
            width: 24px;
            height: 24px;
            margin-right: 5px;
        }
        #menu span {
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        #menu-btn, #stats {
            margin: 0 5px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(to bottom, rgba(222, 184, 135, 0.8), rgba(160, 120, 90, 0.8));
            color: #5D4037;
            border: none;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        #menu-btn:hover, #stats:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            background: linear-gradient(to bottom, rgba(222, 184, 135, 0.9), rgba(160, 120, 90, 0.9));
        }
        .choice-feedback {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform: translateX(-50%);
            width: 32px;
            height: 32px;
            z-index: 4;
            animation: flyUp 3s ease-out forwards;
        }
        @keyframes fall {
            0% { transform: translateY(-10vh); opacity: 1; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        .particle {
            position: absolute;
            background: white;
            border-radius: 50%;
            width: 5px;
            height: 5px;
            opacity: 0.7;
        }
        @keyframes flyUp {
            0% { bottom: 50%; opacity: 1; }
            50% { bottom: 60%; opacity: 0.8; }
            100% { bottom: 70%; opacity: 0; }
        }
        .fade-out {
            opacity: 0;
            transition: opacity 1s ease;
        }
    #start-screen {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('/heart_at_crossroads/assets/backgrounds/start_screen.png') no-repeat center center fixed;
    background-size: cover;
    z-index: 3000; /* Увеличено с 5 до 3000 */
    pointer-events: auto;
    touch-action: auto;
       }
        #start-screen h1 {
            color: #A67C52;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 40px;
            text-align: center;
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }
        #start-screen h1.ru {
            font-family: 'GoodVibesCyr', sans-serif;
        }
        #start-screen h1.en {
            font-family: 'GreatVibes', sans-serif;
        }
        #start-screen h1 span:first-child {
            font-size: 48px;
        }
        #start-screen h1 span:last-child {
            font-size: 40px;
        }
        .start-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            margin-bottom: 30px;
            position: relative;
        }
        .start-buttons button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(245, 240, 225, 0.7);
            color: #5D4037;
            font-size: 16px;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s, box-shadow 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
        }
        .start-buttons button:nth-child(1) {
            left: -30px;
        }
        .start-buttons button:nth-child(2) {
            left: 30px;
        }
        .start-buttons button:nth-child(3) {
            left: -30px;
        }
        #gallery-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(245, 240, 225, 0.7);
            color: #5D4037;
            font-size: 14px;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s, box-shadow 0.3s;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: absolute;
            left: -130px;
            top: 50%;
            transform: translateY(-50%);
        }
        .start-buttons button:hover, #gallery-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            background: rgba(245, 240, 225, 0.9);
        }
        #password-form {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #password-input {
            padding: 12px;
            font-size: 16px;
            border-radius: 20px;
            border: 1px solid rgba(93, 64, 55, 0.3);
            background: rgba(245, 240, 225, 0.7);
            color: #5D4037;
            width: 220px;
            text-align: center;
        }
        #password-submit {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(245, 240, 225, 0.7);
            color: #5D4037;
            font-size: 16px;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #back-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(200, 180, 160, 0.6);
            color: #5D4037;
            font-size: 14px;
            border: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .placeholder-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            z-index: 10;
        }
        #progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: #333;
            z-index: 4;
            display: none;
        }
        #progress {
            width: 0%;
            height: 100%;
            background: #DEB887;
            transition: width 0.5s ease;
        }
        #language-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: transparent;
            border: 1px solid #fff;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            z-index: 6;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #language-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .memory-notification {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to bottom, rgba(222, 184, 135, 0.7), rgba(160, 120, 90, 0.7));
            color: #5D4037;
            padding: 10px;
            border-radius: 5px;
            z-index: 5;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        #debug-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(255, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        #timer-countdown {
        position: absolute;
        bottom: calc(20% + 180px); /* Поднимаем выше */
        left: 50%;
        transform: translateX(-50%);
        font-size: 60px; /* Увеличиваем размер */
        color: #ff4444;
        font-weight: bold;
        z-index: 5; /* Увеличиваем z-index, чтобы был над диалоговым окном */
        }
        @keyframes flash {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
            100% { filter: brightness(1); }
        }
        .flash-svg { animation: flash 0.5s ease; }
        .choice-btn { z-index: 5; }
        .error-message {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 10;
            font-size: 14px;
            text-align: center;
            max-width: 80%;
        }
        .phone-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            width: 240px;
            height: 400px;
            pointer-events: none;
        }


   #gallery-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('/heart_at_crossroads/assets/backgrounds/shoebox_texture.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border: 2px solid #8C6F4A;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        display: none;
        opacity: 0;
        z-index: 2000;
        overflow: hidden;
        padding: 20px;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    #gallery-container::after {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        width: calc(100% + 4px);
        height: calc(100% + 4px);
        border: 2px dashed #8C6F4A;
        pointer-events: none;
    }

    .gallery-header {
        color: #F5E6C9;
        font-size: 3rem; /* Увеличиваем в 1.5 раза (было 2rem) */
        text-align: center;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        opacity: 0;
    }

   .cards-container {
    position: relative;
    height: 600px; /* Фиксированная высота, достаточная для всех карточек */
    width: 100%;
    max-width: 500px;
    margin: 0 auto;
    perspective: 1000px;
    transform-style: preserve-3d;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: visible; /* Убираем обрезку карточек */
}

.cards-container {
    position: relative;
    height: 600px;
    width: 100%;
    max-width: 500px; /* Ограничение ширины контейнера */
    margin: 0 auto;
    perspective: 1000px;
    transform-style: preserve-3d;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: visible;
}

    .premium-card:not(.front) {
        height: 50px;
        opacity: 0.7;
        background: linear-gradient(to bottom, #E0C18E, #BFA78A);
        border-top: 2px solid #FFF;
    }

    .premium-card.front {
        z-index: 100;
        height: 350px;
        opacity: 1;
        background: linear-gradient(to bottom, #FFF5E1, #F5D7A8);
        filter: brightness(1.2);
        box-shadow: 0 6px 20px rgba(245, 215, 168, 0.5);
    }

    .premium-card.peek {
        height: 175px; /* Половина высоты */
        opacity: 1;
        z-index: 90;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    }

    .premium-card.locked {
        background: linear-gradient(to bottom, rgba(245, 230, 201, 0.7), rgba(230, 215, 168, 0.7));
    }

    .premium-card .card-name, .premium-card .unlock-text {
        position: absolute;
        bottom: 0;
        width: 100%;
        text-align: center;
        padding: 5px;
        color: #333;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        font-size: 1.2rem;
    }

    .premium-card.locked .unlock-text {
        color: #777;
        font-size: 0.9rem;
    }

    .card-shine-effect {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.1) 100%);
        pointer-events: none;
        z-index: 5;
    }

    .card-unlock-button {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(to bottom, #8C6F4A, #5A3F2A);
        color: #F5E6C9;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        font-weight: bold;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        cursor: pointer;
        z-index: 2;
    }

    .card-unlock-button:hover, .card-unlock-button:active {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 6px 15px rgba(90, 63, 42, 0.4);
    }

    .card-detail {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1.5);
        z-index: 3000;
        transition: transform 0.4s ease-out;
    }

    .series-title {
        font-size: 1.5rem;
    }

    .camera-btn {
        background: none;
        border: none;
        cursor: pointer;
        position: relative;
        margin-top: 20px;
    }

    .camera-btn svg {
        width: 60px;
        height: 60px;
    }

    .camera-flash {
        position: absolute;
        top: -20px;
        left: 50%;
        transform: translateX(-50%);
        width: 40px;
        height: 40px;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0));
        border-radius: 50%;
        opacity: 0;
        pointer-events: none;
    }

    .camera-btn span {
        position: absolute;
        top: 70px;
        left: 50%;
        transform: translateX(-50%);
        color: #e0c18e;
        font-size: 2.25rem; /* Увеличиваем в 1.5 раза (было 1.5rem) */
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1 id="title" data-ru="Сердце<br>на перекрёстке" data-en="Heart<br>at the Crossroads">
            <span>Сердце</span>
            <span>на перекрёстке</span>
        </h1>
        <div class="start-buttons">
            <button id="start-game" data-ru="Начать игру" data-en="Start Game">Начать игру</button>
            <button id="continue-game" data-ru="Продолжить" data-en="Continue">Продолжить</button>
            <button id="show-password" data-ru="Ввести пароль" data-en="Enter Password">Ввести пароль</button>
            <button id="gallery-btn" data-ru="Галерея" data-en="Gallery">Галерея</button>
        </div>
        <div id="password-form">
            <input type="text" id="password-input" placeholder="Введите пароль">
            <button id="password-submit" data-ru="Войти" data-en="Login">Войти</button>
        </div>
        
        <button id="language-btn">
            <span id="language-icon">🇷🇺</span>
        </button>
    </div>
	
	<div id="gallery-container" style="display: none;">
        <!-- Дочерние элементы будут добавляться динамически -->
       </div>
	
    <div id="game-container">
        <div class="parallax-bg" id="background" style="display: none;"></div>
        <div class="character-left" id="character-left" style="display: none;"></div>
        <div class="character-right" id="character-right" style="display: none;"></div>
        <div class="dialogue-box" id="dialogue-box" style="display: none;">
            <p id="speaker-name"></p>
            <p id="dialogue-text"></p>
        </div>
        <div id="progress-bar" style="display: none;">
            <div id="progress"></div>
        </div>
        <div id="menu" style="display: none;">
            <div id="diamonds">
                <img src="/heart_at_crossroads/assets/ui/diamonds.png" alt="Бриллианты">
                <span id="diamonds-count">100</span>
            </div>
            <button id="menu-btn" data-ru="Меню" data-en="Menu">Меню</button>
            <button id="stats">Статы</button>
        </div>
        <div id="particles" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3;"></div>
    </div>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.5/gsap.min.js"></script>
    <script>
         // Добавляем данные о карточках в начало скрипта
        const cardSeries = {
            "romance": {
                title: "Романтика",
                titleEn: "Romance",
                cards: [                    { id: "card_sergey_and_wife", name: "Сергей и его жена", nameEn: "Sergey and his wife", unlock: "второе прохождение", unlockEn: "second playthrough" },                    { id: "card_anna_and_dima_final", name: "Анна и Дима: фото из финала", nameEn: "Anna and Dima: final photo", unlock: "второе прохождение", unlockEn: "second playthrough" },                    { id: "card_mark_childhood", name: "Марк в детстве", nameEn: "Mark as a child", unlock: "50", unlockEn: "50" },                    { id: "card_katya_and_anna_bff_birthday", name: "Катя и Анна: подруги на дне рожденья", nameEn: "Katya and Anna: friends at a birthday party", unlock: "50", unlockEn: "50" }                ],
                style: "Прошлое остается навсегда",
                styleEn: "The past remains forever"
            }
        };

        // Добавляем SVG украшения
        const svgDecorations = {
            rosePetal: `<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                <path d="M10,25 Q25,5 40,25 Q25,45 10,25 Z" fill="#f8d7da" stroke="#e8b5b9" stroke-width="1" opacity="0.8" />
                <path d="M15,25 Q25,10 35,25 Q25,40 15,25 Z" fill="#f0c1c4" stroke="none" opacity="0.6" />
            </svg>`,
            filmScratch: `<svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
                <filter id="noise">
                    <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch" />
                    <feColorMatrix type="matrix" values="0 0 0 0 0, 0 0 0 0 0, 0 0 0 0 0, 0 0 0 0.15 0" />
                </filter>
                <rect width="100%" height="100%" filter="url(#noise)" opacity="0.08" />
                <line x1="${Math.random() * 100}%" y1="0" x2="${Math.random() * 100}%" y2="100%" stroke="white" stroke-width="0.5" opacity="0.2" />
                <line x1="${Math.random() * 100}%" y1="0" x2="${Math.random() * 100}%" y2="100%" stroke="white" stroke-width="0.8" opacity="0.1" />
            </svg>`
        };

        // Проверка Telegram
        const isTelegram = !!(window.Telegram && window.Telegram.WebApp && Telegram.WebApp.initDataUnsafe);
        if (isTelegram) {
            try {
                Telegram.WebApp.ready();
                console.log('Telegram Web App инициализирован');
            } catch (error) {
                console.error('Ошибка инициализации Telegram:', error);
                alert('Ошибка Telegram Web App. Функции могут быть ограничены.');
            }
        } else {
            console.log('Запуск в браузере');
        }

        const userId = isTelegram ? Telegram.WebApp.initDataUnsafe.user?.id : null;
        let currentChapter = 1;
        let currentScene = 0;
        let choices = [];
        let stats = {
            crown: 0,
            heart: 0,
            leaf: 0,
            diamonds: 100,
            relationships: { mark: 0, lera: 0, vika: 0, sergey: 0, anna: 0, dima: 0, lesha: 0 },
            appearance: "style1",
            isAuthorized: false,
            memories: [],
            language: "ru",
            hasReturnedViaMenu: false,
            completionCount: 0
        };
        let isTyping = false;
        let scriptData = null;
        let currentBackground = null;
        const correctPassword = "umbertoeco";
        const tempPassword = "999000";

        function playSound(sound) {
            if (sound) {
                const audio = new Audio(`/heart_at_crossroads/assets/sounds/${sound}`);
                audio.play()
                    .catch(error => {
                        console.error(`Ошибка воспроизведения звука ${sound}:`, error);
                        showErrorMessage(stats.language === "ru" ? `Звук ${sound} не найден` : `Sound ${sound} not found`);
                    });
            }
        }

        function playMusic(music) {
            if (music) {
                if (window.currentMusic) window.currentMusic.pause();
                window.currentMusic = new Audio(`/heart_at_crossroads/assets/sounds/${music}`);
                window.currentMusic.loop = true;
                window.currentMusic.play()
                    .catch(error => {
                        console.error(`Ошибка воспроизведения музыки ${music}:`, error);
                        showErrorMessage(stats.language === "ru" ? `Музыка ${music} не найдена` : `Music ${music} not found`);
                    });
            }
        }

        function showErrorMessage(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 3000);
        }

        // Улучшенные функции хранения
        function saveToStorage(key, value) {
            return new Promise((resolve, reject) => {
                try {
                    if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.isVersionAtLeast && 
                        window.Telegram.WebApp.isVersionAtLeast('6.0')) {
                        window.Telegram.WebApp.CloudStorage.setItem(key, value)
                            .then(() => {
                                console.log(`Сохранено в Telegram CloudStorage: ${key}`);
                                resolve();
                            })
                            .catch(err => {
                                console.warn('Ошибка Telegram CloudStorage, переход на localStorage:', err);
                                localStorage.setItem(key, value);
                                console.log(`Сохранено в localStorage: ${key}`);
                                resolve();
                            });
                    } else {
                        localStorage.setItem(key, value);
                        console.log(`Сохранено в localStorage: ${key}`);
                        resolve();
                    }
                } catch (error) {
                    console.warn('Ошибка сохранения, переход на in-memory storage:', error);
                    if (!window._inMemoryStorage) window._inMemoryStorage = {};
                    window._inMemoryStorage[key] = value;
                    console.log(`Сохранено в in-memory storage: ${key}`);
                    resolve();
                }
            });
        }

        function getFromStorage(key) {
            return new Promise((resolve, reject) => {
                try {
                    if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.isVersionAtLeast && 
                        window.Telegram.WebApp.isVersionAtLeast('6.0')) {
                        window.Telegram.WebApp.CloudStorage.getItem(key)
                            .then(value => {
                                console.log(`Получено из Telegram CloudStorage: ${key}`);
                                resolve(value);
                            })
                            .catch(err => {
                                console.warn('Ошибка Telegram CloudStorage, переход на localStorage:', err);
                                const value = localStorage.getItem(key);
                                console.log(`Получено из localStorage: ${key}`);
                                resolve(value);
                            });
                    } else {
                        const value = localStorage.getItem(key);
                        console.log(`Получено из localStorage: ${key}`);
                        resolve(value);
                    }
                } catch (error) {
                    console.warn('Ошибка получения, переход на in-memory storage:', error);
                    if (!window._inMemoryStorage) window._inMemoryStorage = {};
                    const value = window._inMemoryStorage[key] || null;
                    console.log(`Получено из in-memory storage: ${key}`);
                    resolve(value);
                }
            });
        }

        function saveSession() {
            const sessionData = JSON.stringify({
                currentScene,
                currentChapter,
                stats,
                choices
            });
            saveToStorage('gameSession', sessionData)
                .then(() => {
                    console.log('Сессия успешно сохранена');
                })
                .catch(error => {
                    console.error('Ошибка сохранения сессии:', error);
                    showDebugMessage('Ошибка сохранения сессии');
                });
        }

        // Утилита для событий
        const addEventListeners = (element, events, handler) => {
            events.forEach(event => {
                element.addEventListener(event, handler);
                console.log(`Привязан ${event} к ${element.id}`);
            });
        };

        // Загрузка DOM
        document.addEventListener('DOMContentLoaded', () => {
            const startGameBtn = document.getElementById('start-game');
            const continueGameBtn = document.getElementById('continue-game');
            const showPasswordBtn = document.getElementById('show-password');
            const passwordSubmitBtn = document.getElementById('password-submit');
            const menuBtn = document.getElementById('menu-btn');
            const statsBtn = document.getElementById('stats');
            const galleryBtn = document.getElementById('gallery-btn');
            const languageBtn = document.getElementById('language-btn');
            const languageIcon = document.getElementById('language-icon');

            if (!startGameBtn) console.error('Кнопка start-game не найдена!');
            updateLanguage(stats.language);

            // Обработчики с логированием
            function handleStartGame(e) {
                e.preventDefault();
                console.log('handleStartGame вызван');
                checkTempPassword(() => startNewGame());
            }

            function handleContinueGame(e) {
                e.preventDefault();
                console.log('handleContinueGame вызван');
                checkTempPassword(() => loadSession(() => startGame()));
            }

            function handleShowPassword(e) {
                e.preventDefault();
                console.log('handleShowPassword вызван');
                document.getElementById('password-form').style.display = 'flex';
                document.querySelector('.start-buttons').style.display = 'none';
            }

            async function handlePasswordSubmit(e) {
                e.preventDefault();
                console.log('handlePasswordSubmit вызван');
                const inputPassword = document.getElementById('password-input').value;
                try {
                    if (inputPassword === tempPassword || inputPassword === correctPassword) {
                        if (inputPassword === correctPassword) {
                            let authorizedUsers = JSON.parse(await getFromStorage('authorized_users') || '[]');
                            if (userId && !authorizedUsers.includes(userId)) {
                                authorizedUsers.push(userId);
                                await saveToStorage('authorized_users', JSON.stringify(authorizedUsers));
                            }
                            stats.isAuthorized = true;
                        }
                        startNewGame();
                    } else {
                        alert(stats.language === "ru" ? 'Неверный пароль!' : 'Incorrect password!');
                    }
                } catch (error) {
                    console.error('Ошибка обработки пароля:', error);
                    alert(stats.language === "ru" ? 'Ошибка авторизации.' : 'Authorization error.');
                }
            }

            function handleMenu(e) {
                e.preventDefault();
                console.log('handleMenu вызван');
                stats.hasReturnedViaMenu = true;
                resetGameState();
                saveSession();
                showStartScreen();
            }

            function handleShowStats(e) {
                e.preventDefault();
                console.log('handleShowStats вызван');
                const statsText = stats.language === "ru" ?
                    `Короны: ${stats.crown}\nСердце: ${stats.heart}\nЛист: ${stats.leaf}\nБриллианты: ${stats.diamonds}\nОтношения:\nМарк: ${stats.relationships.mark}\nЛера: ${stats.relationships.lera}\nВика: ${stats.relationships.vika}\nСергей: ${stats.relationships.sergey}\nАнна: ${stats.relationships.anna}\nДима: ${stats.relationships.dima}\nЛёша: ${stats.relationships.lesha}` :
                    `Crowns: ${stats.crown}\nHeart: ${stats.heart}\nLeaf: ${stats.leaf}\nDiamonds: ${stats.diamonds}\nRelationships:\nMark: ${stats.relationships.mark}\nLera: ${stats.relationships.lera}\nVika: ${stats.relationships.vika}\nSergey: ${stats.relationships.sergey}\nAnna: ${stats.relationships.anna}\nDima: ${stats.relationships.dima}\nLesha: ${stats.relationships.lesha}`;
                alert(statsText);
            }

            function handleShowGallery(e) {
            e.preventDefault();
            console.log('handleShowGallery вызван');
            showPremiumGallery();
                }

            function handleLanguageSwitch(e) {
                e.preventDefault();
                console.log('handleLanguageSwitch вызван');
                stats.language = stats.language === "ru" ? "en" : "ru";
                languageIcon.textContent = stats.language === "ru" ? "🇷🇺" : "🇬🇧";
                updateLanguage(stats.language);
                saveSession();
            }

            // Привязка событий
            addEventListeners(startGameBtn, ['click', 'touchstart'], handleStartGame);
            addEventListeners(continueGameBtn, ['click', 'touchstart'], handleContinueGame);
            addEventListeners(showPasswordBtn, ['click', 'touchstart'], handleShowPassword);
            addEventListeners(passwordSubmitBtn, ['click', 'touchstart'], handlePasswordSubmit);
            addEventListeners(menuBtn, ['click', 'touchstart'], handleMenu);
            addEventListeners(statsBtn, ['click', 'touchstart'], handleShowStats);
            addEventListeners(galleryBtn, ['click', 'touchstart'], (e) => e.preventDefault());
            addEventListeners(galleryBtn, ['click', 'touchstart'], handleShowGallery);
            addEventListeners(languageBtn, ['click', 'touchstart'], handleLanguageSwitch);

            // Кнопка "Назад"
            const backButton = document.createElement('button');
            backButton.id = 'back-button';
            backButton.textContent = stats.language === "ru" ? "Назад" : "Back";
            addEventListeners(backButton, ['click', 'touchstart'], (e) => {
                e.preventDefault();
                console.log('backButton вызван');
                document.getElementById('password-form').style.display = 'none';
                document.querySelector('.start-buttons').style.display = 'flex';
            });
            document.getElementById('password-form').appendChild(backButton);

            // Инициализация
            getFromStorage('last_session')
                .then(session => {
                    console.log('Сессия загружена:', session);
                    if (session) showStartScreen();
                    else checkAuthorization();
                })
                .catch(error => {
                    console.error('Ошибка загрузки сессии:', error);
                    showStartScreen();
                });
        });

        // Остальные функции
        function clearEventListeners(element, events) {
        events.forEach(event => {
        element.removeEventListener(event, element[event + 'Handler']);
        element[event + 'Handler'] = null;
       });
       }

    function showStartScreen() {
    console.log('showStartScreen вызван');
    const startScreen = document.getElementById('start-screen');
    const gameContainer = document.getElementById('game-container');
    const galleryContainer = document.getElementById('gallery-container');
    const languageBtn = document.getElementById('language-btn');

    startScreen.style.display = 'flex';
    languageBtn.style.display = 'block';
    gameContainer.style.display = 'none';
    galleryContainer.style.display = 'none'; // Убеждаемся, что галерея скрыта
}

        function resetGameState() {
            console.log('resetGameState вызван');
            currentChapter = 1;
            currentScene = 0;
            choices = [];
            stats = {
                crown: 0,
                heart: 0,
                leaf: 0,
                diamonds: 10,
                relationships: { mark: 0, lera: 0, vika: 0, sergey: 0, anna: 0, dima: 0, lesha: 0 },
                appearance: "style1",
                isAuthorized: stats.isAuthorized,
                memories: [],
                language: stats.language,
                hasReturnedViaMenu: true,
                completionCount: stats.completionCount
            };
            currentBackground = null;
        }

        function updateLanguage(lang) {
            console.log('updateLanguage вызван с языком:', lang);
            document.getElementById('start-game').textContent = document.getElementById('start-game').getAttribute(`data-${lang}`);
            document.getElementById('continue-game').textContent = document.getElementById('continue-game').getAttribute(`data-${lang}`);
            document.getElementById('show-password').textContent = document.getElementById('show-password').getAttribute(`data-${lang}`);
            document.getElementById('password-submit').textContent = document.getElementById('password-submit').getAttribute(`data-${lang}`);
            document.getElementById('menu-btn').textContent = document.getElementById('menu-btn').getAttribute(`data-${lang}`);
            document.getElementById('gallery-btn').textContent = document.getElementById('gallery-btn').getAttribute(`data-${lang}`);
            const title = document.getElementById('title');
            title.innerHTML = lang === "ru" ? '<span>Сердце</span><span>на перекрёстке</span>' : '<span>Heart</span><span>at the Crossroads</span>';
            title.className = lang === "ru" ? "ru" : "en";
        }

        async function checkAuthorization() {
            try {
                const authorizedUsers = (await getFromStorage('authorized_users')) || [];
                if (userId && authorizedUsers.includes(userId)) {
                    stats.isAuthorized = true;
                    startGame();
                } else {
                    showStartScreen();
                }
            } catch (error) {
                console.error('Ошибка авторизации:', error);
                showStartScreen();
            }
        }

        async function checkTempPassword(callback) {
            try {
                const granted = await getFromStorage('tempAccessGranted');
                if (granted) {
                    console.log('Временный доступ уже предоставлен');
                    callback();
                } else {
                    const input = prompt(stats.language === "ru" ? 'Игра закрыта на доработку. Введите пароль:' : 'Game is under refinement. Enter password:');
                    if (input === tempPassword || input === correctPassword) {
                        await saveToStorage('tempAccessGranted', true);
                        if (input === correctPassword) stats.isAuthorized = true;
                        console.log('Пароль верный, доступ предоставлен');
                        callback();
                    } else {
                        alert(stats.language === "ru" ? 'Неверный пароль!' : 'Incorrect password!');
                    }
                }
            } catch (error) {
                console.error('Ошибка проверки пароля:', error);
                alert(stats.language === "ru" ? 'Ошибка доступа.' : 'Access error.');
            }
        }

        function startNewGame() {
            console.log('startNewGame вызван');
            resetGameState();
            saveSession();
            startGame();
        }

        async function loadSession(callback) {
            try {
                const session = await getFromStorage('last_session');
                if (session) {
                    currentChapter = session.currentChapter;
                    currentScene = session.currentScene;
                    choices = session.choices;
                    stats = { ...stats, ...session.stats };
                    console.log('Сессия загружена:', session);
                }
                if (callback) callback();
            } catch (error) {
                console.error('Ошибка загрузки сессии:', error);
            }
        }

               function showMessengerOverlay(sceneId) {
    console.log(`Создание оверлея для сцены ${sceneId}`);
    const existingOverlay = document.getElementById('messenger-overlay');
    if (existingOverlay) existingOverlay.remove();

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('id', 'messenger-overlay');
    svg.setAttribute('width', '240');
    svg.setAttribute('height', '400');
    svg.setAttribute('viewBox', '0 0 300 500');
    svg.classList.add('phone-overlay'); // Добавляем класс из CSS

    let avatarSrc, senderName, messages;
    if (sceneId === 7) {
        avatarSrc = "/heart_at_crossroads/assets/characters/lesha/lyosha_messenger_ava.png";
        senderName = "Лёша";
        messages = [
            { id: "msg1", x: 50, y: 120, width: 160, textX: 60, textY: 145, text: stats.language === "ru" ? "Тусим вечером" : "Party tonight" },
            { id: "msg2", x: 50, y: 180, width: 100, textX: 60, textY: 205, text: stats.language === "ru" ? "Дима будет" : "Dima’s coming" },
            { id: "msg3", x: 50, y: 240, width: 90, textX: 60, textY: 265, text: stats.language === "ru" ? "Приходи" : "Be there" }
        ];
    } else if (sceneId === 21) {
        avatarSrc = "/heart_at_crossroads/assets/characters/mark/mark_messenger_ava.png";
        senderName = "Марк";
        const fullText = stats.language === "ru" ? "Ты красивая, когда теряешься" : "You’re beautiful when you’re lost";
        const maxCharsPerLine = 15;
        const lines = [];
        let currentLine = "";
        fullText.split(" ").forEach(word => {
            if ((currentLine + word).length <= maxCharsPerLine) {
                currentLine += (currentLine ? " " : "") + word;
            } else {
                lines.push(currentLine);
                currentLine = word;
            }
        });
        if (currentLine) lines.push(currentLine);
        messages = lines.map((line, idx) => ({
            id: `msg${idx + 1}`,
            x: 50,
            y: 120 + idx * 40,
            width: 180,
            textX: 60,
            textY: 145 + idx * 40,
            text: line
        }));
    } else {
        // Дефолтный случай для других сцен с "телефоном"
        const sceneData = scriptData.scenes.find(s => s.id === sceneId) || {};
        avatarSrc = `/heart_at_crossroads/assets/characters/${sceneData.speaker?.[stats.language]?.toLowerCase() || 'unknown'}/${sceneData.speaker?.[stats.language]?.toLowerCase() || 'unknown'}_messenger_ava.png`;
        senderName = sceneData.speaker?.[stats.language] || "Unknown";
        messages = [{
            id: "msg1",
            x: 50,
            y: 120,
            width: 200,
            textX: 60,
            textY: 145,
            text: sceneData.text?.[stats.language]?.substring(0, 50) || "Сообщение..."
        }];
    }

    svg.innerHTML = `
        <!-- Корпус смартфона -->
        <rect x="20" y="20" width="260" height="460" rx="30" fill="#333" stroke="#555" stroke-width="2"/>
        <!-- Экран смартфона с фоновым изображением -->
        <rect x="30" y="50" width="240" height="400" rx="10" fill="#fff"/>
        <image xlink:href="/heart_at_crossroads/assets/backgrounds/bg_phone_messenger.png" x="30" y="50" width="240" height="400" preserveAspectRatio="xMidYMid slice" opacity="0.3"/>
        <!-- Заголовок Telegram с именем пользователя и аватаркой -->
        <rect x="30" y="50" width="240" height="50" fill="#fff"/>
        <clipPath id="avatarClip">
            <circle cx="60" cy="75" r="15"/>
        </clipPath>
        <image xlink:href="${avatarSrc}" x="45" y="60" width="30" height="30" clip-path="url(#avatarClip)" onerror="console.error('Ошибка загрузки аватарки: ${avatarSrc}')"/>
        <circle cx="60" cy="75" r="15" fill="none" stroke="#ccc" stroke-width="1"/>
        <text x="85" y="85" fill="#000" font-size="16" font-family="Arial, sans-serif">${senderName}</text>
        <!-- Разделительная линия -->
        <line x1="30" y1="100" x2="270" y2="100" stroke="#ccc" stroke-width="1"/>
        <!-- Сообщения -->
        <g class="messages">
            ${messages.map((msg, idx) => `
                <rect id="msg${idx + 1}" x="${msg.x}" y="${msg.y}" width="${msg.width}" height="${40 * (Math.ceil(msg.text.length / 15) || 1)}" rx="10" fill="#E1F5C4"/>
                <text id="text${idx + 1}" x="${msg.textX}" y="${msg.textY}" fill="#000" font-size="14" font-family="Arial, sans-serif">${msg.text}</text>
            `).join('')}
            <!-- Пустое ответное сообщение -->
            <rect id="msg${messages.length + 1}" x="120" y="${messages.length * 60 + 180}" width="100" height="40" rx="10" fill="#fff" stroke="#ccc" stroke-width="1"/>
            <text id="text${messages.length + 1}" x="130" y="${messages.length * 60 + 205}" fill="#000" font-size="14" font-family="Arial, sans-serif" opacity="0">...</text>
        </g>
    `;

    console.log(`Добавление SVG в DOM для сцены ${sceneId}`);
    document.getElementById('game-container').appendChild(svg);

    // Анимация появления
    console.log(`Запуск анимации для сцены ${sceneId}`);
    gsap.from(svg, { y: -20, opacity: 0, duration: 0.5 });
    messages.forEach((msg, idx) => {
        gsap.from(`#msg${idx + 1}, #text${idx + 1}`, { y: 20, opacity: 0, duration: 1, delay: 0.5 + idx * 0.5 });
    });
    gsap.from(`#msg${messages.length + 1}`, { y: 20, opacity: 0, duration: 1, delay: 0.5 + messages.length * 0.5 });
    gsap.to(`#text${messages.length + 1}`, { 
        opacity: 1, 
        duration: 0, 
        delay: 0.5 + messages.length * 0.5 + 0.5, 
        onStart: function() {
            let text = "...";
            let index = 0;
            let interval = setInterval(() => {
                document.getElementById(`text${messages.length + 1}`).textContent = text.slice(0, index);
                index++;
                if (index > text.length) clearInterval(interval);
            }, 100);
        }
    });

    return svg;
}

function createDefaultOverlay(sceneId, sceneData = {}) {
    console.log(`Создание стандартного оверлея для сцены ${sceneId}`);
    const overlay = document.createElement('div');
    overlay.classList.add('phone-overlay');
    overlay.style.background = 'url(/heart_at_crossroads/assets/backgrounds/bg_phone_messenger.png) no-repeat center/cover';
    
    const speaker = sceneData.speaker ? sceneData.speaker[stats.language] : 'Unknown';
    const avatar = document.createElement('img');
    avatar.src = `/heart_at_crossroads/assets/characters/${speaker.toLowerCase()}/${speaker.toLowerCase()}_messenger_ava.png`;
    avatar.style.width = '40px';
    avatar.style.height = '40px';
    avatar.style.position = 'absolute';
    avatar.style.top = '20px';
    avatar.style.left = '20px';
    avatar.onerror = () => console.warn(`Аватар для ${speaker} не найден`);
    overlay.appendChild(avatar);

    const name = document.createElement('div');
    name.textContent = speaker;
    name.style.position = 'absolute';
    name.style.top = '25px';
    name.style.left = '70px';
    name.style.color = '#fff';
    name.style.fontSize = '16px';
    overlay.appendChild(name);

    const message = document.createElement('div');
    message.textContent = sceneData.text ? sceneData.text[stats.language].substring(0, 100) : '';
    message.style.position = 'absolute';
    message.style.top = '70px';
    message.style.left = '20px';
    message.style.right = '20px';
    message.style.color = '#fff';
    message.style.fontSize = '14px';
    overlay.appendChild(message);

    document.getElementById('game-container').appendChild(overlay);
    return overlay;
}


        async function startGame() {
            try {
                console.log('startGame вызван');
                showDebugMessage('Инициализация игры...');
                document.getElementById('game-container').style.display = 'block';
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('language-btn').style.display = 'none';

                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'loading-overlay';
                loadingOverlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:#000;z-index:10;display:flex;justify-content:center;align-items:center;color:#fff;';
                loadingOverlay.innerHTML = '<span>Загрузка...</span>';
                document.body.appendChild(loadingOverlay);

                await preloadAssets(currentChapter);
                await loadChapter(currentChapter);

                document.getElementById('background').style.display = 'block';
                document.getElementById('character-left').style.display = 'block';
                document.getElementById('character-right').style.display = 'block';
                document.getElementById('dialogue-box').style.display = 'block';
                document.getElementById('menu').style.display = 'flex';
                document.getElementById('progress-bar').style.display = 'block';

                document.getElementById('stats').style.display = stats.isAuthorized ? 'block' : 'none';
                updateDiamondsDisplay();

                loadingOverlay.remove();
                showScene(currentScene);
            } catch (error) {
                console.error('Ошибка в startGame:', error);
                showDebugMessage(`Ошибка: ${error.message}`);
                alert(stats.language === "ru" ? 'Ошибка запуска игры.' : 'Game start error.');
                document.getElementById('loading-overlay')?.remove();
                showStartScreen();
            }
        }

        function updateDiamondsDisplay() {
            document.getElementById('diamonds-count').textContent = stats.diamonds;
        }

        function showDebugMessage(message) {
            let debugDiv = document.getElementById('debug-message');
            if (!debugDiv) {
                debugDiv = document.createElement('div');
                debugDiv.id = 'debug-message';
                document.body.appendChild(debugDiv);
            }
            debugDiv.textContent = message;
            setTimeout(() => debugDiv.remove(), 5000);
        }

        function checkAssetExists(url) {
            return fetch(url, { method: 'HEAD' })
                .then(res => res.ok)
                .catch(() => false);
        }
        

        async function preloadAssets(chapterId, options = {}) {
            console.log(`Начало загрузки ресурсов для главы: ${chapterId}`);
            const language = options.language || 'ru';
            const texts = {
                loading: language === 'ru' ? 'Загрузка' : 'Loading',
                imageNotFound: language === 'ru' ? 'Изображение не найдено' : 'Image not found',
                loadError: language === 'ru' ? 'Не удалось загрузить' : 'Failed to load'
            };
            const loadingStatus = document.createElement('div');
            loadingStatus.id = 'loading-status';
            loadingStatus.style.cssText = 'position: fixed; bottom: 10px; left: 10px; color: white; font-size: 12px; z-index: 11; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 3px;';
            document.body.appendChild(loadingStatus);
            const images = [
                '/heart_at_crossroads/assets/backgrounds/start_screen.png',
                '/heart_at_crossroads/assets/backgrounds/bg_apartment_morning.png',
                '/heart_at_crossroads/assets/backgrounds/bg_coffee_shop.png',
                '/heart_at_crossroads/assets/backgrounds/bg_phone_messenger.png',
                '/heart_at_crossroads/assets/backgrounds/bg_street_day_trash.png',
                '/heart_at_crossroads/assets/backgrounds/bg_street_dusk_end.png',
                '/heart_at_crossroads/assets/backgrounds/bg_street_night.png',
                '/heart_at_crossroads/assets/backgrounds/bg_webstudio_day.png',
                '/heart_at_crossroads/assets/backgrounds/bg_webstudio_night.png',
                '/heart_at_crossroads/assets/characters/anna/anna_angry_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_happy_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_happy_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_neutral_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_neutral_style1_summer.png',
                '/heart_at_crossroads/assets/characters/anna/anna_neutral_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_neutral_style3.png',
                '/heart_at_crossroads/assets/characters/anna/anna_sad_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_sad_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_smile_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_smile_style1_summer.png',
                '/heart_at_crossroads/assets/characters/anna/anna_smile_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_smile_style2_summer.png',
                '/heart_at_crossroads/assets/characters/anna/anna_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_surprised_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_surprised_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_thoughtful_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_thoughtful_style1_summer.png',
                '/heart_at_crossroads/assets/characters/anna/anna_thoughtful_style2.png',
                '/heart_at_crossroads/assets/characters/anna/anna_worry_style1.png',
                '/heart_at_crossroads/assets/characters/anna/anna_worry_style2.png',
                '/heart_at_crossroads/assets/characters/dima/dima_happy_style1.png',
                '/heart_at_crossroads/assets/characters/dima/dima_neutral_style1.png',
                '/heart_at_crossroads/assets/characters/dima/dima_sad_style1.png',
                '/heart_at_crossroads/assets/characters/dima/dima_smile_style1.png',
                '/heart_at_crossroads/assets/characters/dima/dima_surprised_style1.png',
                '/heart_at_crossroads/assets/characters/dima/dima_thoughtful_style1.png',
                '/heart_at_crossroads/assets/characters/dima/dima_worry_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_happy_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_messenger_ava.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_neutral_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_sad_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_smile_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_surprised_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_thoughtful_style1.png',
                '/heart_at_crossroads/assets/characters/lesha/lyosha_worry_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_happy_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_messenger_ava.png',
                '/heart_at_crossroads/assets/characters/mark/mark_neutral_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_sad_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_smile_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_surprised_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_thoughtful_style1.png',
                '/heart_at_crossroads/assets/characters/mark/mark_worry_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_happy_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_neutral_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_sad_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_smile_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_surprised_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_thoughtful_style1.png',
                '/heart_at_crossroads/assets/characters/sergey/sergey_worry_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_confident_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_happy_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_happy_style1_summer.png',
                '/heart_at_crossroads/assets/characters/vika/vika_neutral_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_sad_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_sad_style1_summer.png',
                '/heart_at_crossroads/assets/characters/vika/vika_smile_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_surprised_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_thoughtful_style1.png',
                '/heart_at_crossroads/assets/characters/vika/vika_worry_style1.png'
            ];
            let loaded = 0;
            const totalImages = images.length;
            const failedImages = [];
            const updateStatus = () => {
                const percentage = Math.floor((loaded / totalImages) * 100);
                loadingStatus.textContent = `${texts.loading}: ${loaded}/${totalImages} (${percentage}%)`;
            };
            const showErrorMessage = (message) => {
                const errorElement = document.createElement('div');
                errorElement.style.cssText = 'position: fixed; top: 10px; right: 10px; background: rgba(255,0,0,0.7); color: white; padding: 10px; z-index: 9999; border-radius: 5px;';
                errorElement.textContent = message;
                document.body.appendChild(errorElement);
                setTimeout(() => {
                    errorElement.style.opacity = '0';
                    errorElement.style.transition = 'opacity 0.5s';
                    setTimeout(() => errorElement.remove(), 500);
                }, 3000);
            };
            updateStatus();
            try {
                const promises = images.map(src => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            loaded++;
                            updateStatus();
                            console.log(`✅ ${texts.loading}: ${src}`);
                            resolve(true);
                        };
                        img.onerror = () => {
                            loaded++;
                            failedImages.push(src.split('/').pop());
                            updateStatus();
                            console.warn(`❌ ${texts.loadError}: ${src}`);
                            resolve(false);
                        };
                        img.src = src;
                    });
                });
                const results = await Promise.all(promises);
                const successCount = results.filter(success => success).length;
                console.log(`✅ ${texts.loading}: ${successCount}/${totalImages} успешно загружены`);
                if (failedImages.length > 0) {
                    failedImages.slice(0, 3).forEach(img => {
                        showErrorMessage(`${texts.imageNotFound}: ${img}`);
                    });
                    if (failedImages.length > 3) {
                        showErrorMessage(`${texts.imageNotFound}: ${failedImages.length - 3} more...`);
                    }
                }
                return { 
                    success: successCount, 
                    failed: failedImages.length, 
                    failedImages 
                };
            } catch (error) {
                console.error('Ошибка при загрузке изображений:', error);
                throw error;
            } finally {
                loadingStatus.style.opacity = '0';
                loadingStatus.style.transition = 'opacity 0.5s';
                setTimeout(() => loadingStatus.remove(), 500);
            }
        }

        async function loadChapter(chapterId) {
    console.log(`Загрузка главы ${chapterId}`);
    const jsonPath = `/heart_at_crossroads/assets/data/chapter${chapterId}.json`;
    try {
        const response = await fetch(jsonPath, {
            headers: {
                'Content-Type': 'application/json; charset=UTF-8',
                'Accept': 'application/json'
            }
        });
        if (!response.ok) {
            console.error(`Ошибка загрузки ${jsonPath}: ${response.status} ${response.statusText}`);
            showErrorMessage(stats.language === "ru" ? `Глава ${chapterId} не найдена` : `Chapter ${chapterId} not found`);
            showStartScreen();
            return false;
        }
        const text = await response.text();
        const data = JSON.parse(text);
        if (!data || !data.scenes || !Array.isArray(data.scenes)) {
            throw new Error('Некорректный формат JSON');
        }
        scriptData = data;
        console.log(`Глава ${chapterId} загружена:`, scriptData);
        return true;
    } catch (error) {
        console.error(`Ошибка загрузки главы ${chapterId}:`, error);
        showErrorMessage(stats.language === "ru" ? `Ошибка загрузки главы ${chapterId}` : `Error loading chapter ${chapterId}`);
        showStartScreen();
        return false;
    }
}

        function createChoiceButton(choice) {
            const btn = document.createElement('button');
            const hasCostInText = choice.text[stats.language].includes(`${choice.cost}`);
            let buttonText = choice.text[stats.language].replace(" (10 сек)", "").replace(" (10 sec)", "");
            btn.textContent = choice.cost && !hasCostInText 
                ? `${buttonText} (${choice.cost} бриллиантов)` 
                : buttonText;
            btn.className = 'choice-btn';
            if (choice.text[stats.language].length > 30) btn.style.fontSize = '12px';
            if (choice.text[stats.language].length > 60) btn.style.minHeight = '64px';
            return btn;
        }

        function saveChoice(choiceId, effects, memoryTag) {
            choices.push(choiceId);
            if (effects) {
                for (let key in effects) {
                    if (key === 'relationships') {
                        for (let rel in effects[key]) {
                            stats.relationships[rel] = (stats.relationships[rel] || 0) + effects[key][rel];
                        }
                    } else {
                        stats[key] = (stats[key] || 0) + effects[key];
                    }
                }
            }
            if (memoryTag) {
                stats.memories.push(memoryTag);
                const notification = document.createElement('div');
                notification.className = 'memory-notification';
                notification.textContent = stats.language === "ru" ? "Вика запомнит ваш выбор" : "Vika will remember your choice";
                document.getElementById('game-container').appendChild(notification);
                setTimeout(() => notification.remove(), 3000);
            }
            saveSession();
        }

            // Обновление прогресс-бара
function updateProgress(sceneId, totalScenes) {
    console.log(`[updateProgress] Обновляем прогресс: ${sceneId + 1}/${totalScenes}`);
    const progressElement = document.getElementById('progress');
    const progressPercent = ((sceneId + 1) / totalScenes) * 100;
    progressElement.style.width = `${progressPercent}%`;
}

// Настройка фона с проверкой
async function setupBackground(newBackground, language) {
    console.log(`[setupBackground] Устанавливаем фон: ${newBackground}`);
    const bgUrl = newBackground === 'none' ? 'none' : `/heart_at_crossroads/assets/backgrounds/${newBackground}.png`;
    if (bgUrl !== 'none') {
        const exists = await checkAssetExists(bgUrl);
        console.log(`[setupBackground] Проверка фона ${bgUrl}: ${exists ? 'найден' : 'не найден'}`);
        if (!exists) {
            console.warn(`Фон ${newBackground}.png не найден`);
            showErrorMessage(language === "ru" ? `Фон ${newBackground} не найден` : `Background ${newBackground} not found`);
        }
    }
    document.getElementById('background').style.backgroundImage = bgUrl === 'none' ? 'none' : `url('${bgUrl}')`;
    return newBackground;
}

// Настройка персонажей
async function setupCharacters(scene, language, stats) {
    console.log(`[setupCharacters] Настройка персонажей для сцены ${scene.id}`);
    const charLeft = document.getElementById('character-left');
    const charRight = document.getElementById('character-right');
    const speakerName = scene.speaker ? scene.speaker[language] : '';

    charLeft.style.backgroundImage = 'none';
    charRight.style.backgroundImage = 'none';
    charLeft.classList.remove('character-speaker', 'character-non-speaker', 'shiver', 'heartbeat');
    charRight.classList.remove('character-speaker', 'character-non-speaker', 'shiver', 'heartbeat');

    if (scene.characterLeft) {
        const leftChar = scene.characterLeft.includes('${stats.appearance}')
            ? scene.characterLeft.replace('${stats.appearance}', stats.appearance)
            : scene.characterLeft;
        const leftCharUrl = `/heart_at_crossroads/assets/characters/${leftChar.split('_')[0]}/${leftChar}.png`;
        const exists = await checkAssetExists(leftCharUrl);
        console.log(`[setupCharacters] Проверка персонажа ${leftCharUrl}: ${exists ? 'найден' : 'не найден'}`);
        if (!exists) {
            console.warn(`Персонаж ${leftChar}.png не найден`);
            showErrorMessage(language === "ru" ? `Персонаж ${leftChar} не найден` : `Character ${leftChar} not found`);
        }
        charLeft.style.backgroundImage = `url('${leftCharUrl}')`;
        charLeft.classList.add(speakerName === "Анна" || speakerName === "Anna" ? 'character-speaker' : 'character-non-speaker');
    }

    if (scene.characterRight) {
        const rightChar = scene.characterRight.includes('${stats.appearance}')
            ? scene.characterRight.replace('${stats.appearance}', stats.appearance)
            : scene.characterRight;
        const rightCharUrl = `/heart_at_crossroads/assets/characters/${rightChar.split('_')[0]}/${rightChar}.png`;
        const exists = await checkAssetExists(rightCharUrl);
        console.log(`[setupCharacters] Проверка персонажа ${rightCharUrl}: ${exists ? 'найден' : 'не найден'}`);
        if (!exists) {
            console.warn(`Персонаж ${rightChar}.png не найден`);
            showErrorMessage(language === "ru" ? `Персонаж ${rightChar} не найден` : `Character ${rightChar} not found`);
        }
        charRight.style.backgroundImage = `url('${rightCharUrl}')`;
        charRight.classList.add(speakerName === "Вика" || speakerName === "Vika" ? 'character-speaker' : 'character-non-speaker');
    }

    document.getElementById('speaker-name').textContent = speakerName;
    console.log(`[setupCharacters] Имя спикера: ${speakerName}`);
}

// Создание оверлея
   function createOverlayIfNeeded(sceneId, displayText, hasTimer = false) {
    console.log(`[createOverlayIfNeeded] Проверка сцены ${sceneId}, hasTimer: ${hasTimer}`);
    const sceneData = scriptData.scenes.find(s => s.id === sceneId) || {};
    
    // Проверяем поле phone в данных сцены
    const hasPhoneField = sceneData.phone === 1;
    
    if (hasPhoneField) {
        if (hasTimer) {
            console.log(`[createOverlayIfNeeded] Создаём showMessengerOverlay для сцены ${sceneId} (phone=1, hasTimer=true)`);
            return showMessengerOverlay(sceneId);
        } else {
            console.log(`[createOverlayIfNeeded] Создаём createDefaultOverlay для сцены ${sceneId} (phone=1, hasTimer=false)`);
            return createDefaultOverlay(sceneId, sceneData);
        }
        }
      return null;
      }

// Очистка обработчиков
function clearDialogueHandlers(dialogueBox) {
    console.log('[clearDialogueHandlers] Очистка старых обработчиков');
    dialogueBox.onclick = null;
    dialogueBox.ontouchstart = null;
    document.querySelectorAll('.choice-btn').forEach(btn => btn.remove());
}

// Обработка выбора
function handleChoices(scene, dialogueBox, overlay) {
    dialogueBox.style.pointerEvents = 'auto';
    if (!scene.choices || scene.choices.length === 0) return;

    console.log(`[handleChoices] Обработка выбора для сцены ${scene.id}`);
    if (scene.choices.some(c => c.timer)) {
        console.log(`[${Date.now()}] Переход к showSceneWithTimer`);
        showSceneWithTimer(scene);
    } else {
        console.log(`[${Date.now()}] Показываем кнопки выбора`);
        scene.choices.forEach(choice => {
            const btn = createChoiceButton(choice);
            if (choice.condition && !checkCondition(choice.condition)) {
                btn.style.display = 'none';
            } else if (choice.cost && stats.diamonds < choice.cost) {
                btn.disabled = true;
            } else {
                const handleChoice = (e) => {
                    e.preventDefault();
                    console.log(`[${Date.now()}] Выбор сделан: ${choice.id}`);
                    if (choice.cost) stats.diamonds -= choice.cost;
                    updateDiamondsDisplay();
                    saveChoice(choice.id, choice.effects, choice.memoryTag);
                    if (choice.effects) showChoiceEffects(choice.effects);
                    if (overlay) overlay.remove();
                    if (choice.nextScene !== undefined) {
                        currentScene = choice.nextScene;
                        saveSession();
                        showScene(currentScene);
                    } else if (choice.nextChapter) {
                        currentChapter = choice.nextChapter;
                        currentScene = 0;
                        loadChapter(currentChapter).then(() => showScene(currentScene));
                    }
                };
                btn.addEventListener('touchstart', handleChoice);
                btn.addEventListener('click', handleChoice);
            }
            dialogueBox.appendChild(btn);
        });
    }
}

// Обработка следующей сцены
       function handleNextScene(scene, dialogueBox, overlay) {
    if (!scene.nextScene) return;

    console.log(`[${Date.now()}] Установка обработчика для перехода к сцене ${scene.nextScene}`);
    console.log(`[handleNextScene] Параметры: scene.id=${scene.id}, dialogueBox=${dialogueBox ? 'найден' : 'не найден'}, overlay=${overlay ? 'найден' : 'не найден'}`);
    if (!dialogueBox) {
        console.error('[handleNextScene] dialogueBox не найден!');
        return;
    }

    const handleNext = (e) => {
        e.preventDefault();
        console.log(`[${Date.now()}] Тап: переход к сцене ${scene.nextScene}`);
        currentScene = scene.nextScene;
        saveSession();
        if (overlay) overlay.remove();
        dialogueBox.style.pointerEvents = 'none';
        dialogueBox.removeEventListener('touchstart', handleNext, { passive: false });
        dialogueBox.removeEventListener('click', handleNext);
        showScene(currentScene);
    };

    // Очистка старых обработчиков
    if (dialogueBox.touchHandler) {
        dialogueBox.removeEventListener('touchstart', dialogueBox.touchHandler, { passive: false });
        dialogueBox.removeEventListener('click', dialogueBox.touchHandler);
        console.log('[handleNextScene] Очищены старые touchHandler');
    }

    dialogueBox.touchHandler = handleNext;
    dialogueBox.addEventListener('touchstart', handleNext, { passive: false });
    dialogueBox.addEventListener('click', handleNext);
    dialogueBox.style.pointerEvents = 'auto';
    console.log(`[handleNextScene] Обработчики установлены, pointerEvents: ${dialogueBox.style.pointerEvents}`);
}

// Обработка конца главы
   function handleChapterEnd(scene) {
    if (scene.id !== scriptData.scenes.length - 1) return;

    console.log(`[${Date.now()}] Конец главы ${currentChapter}, переход к следующей`);
    currentChapter++;
    currentScene = 0;
    loadChapter(currentChapter).then(success => {
        if (success) {
            console.log(`Переход к сцене ${currentScene} главы ${currentChapter}`);
            showScene(currentScene);
        } else {
            console.warn(`Не удалось загрузить главу ${currentChapter}`);
        }
    });
}

    async function showScene(sceneId) {
    console.log(`Показ сцены ${sceneId}`);
    const scene = scriptData.scenes.find(s => s.id === sceneId);
    if (!scene) {
        console.error('Сцена не найдена:', sceneId);
        return;
    }

    const progressElement = document.getElementById('progress');
    const totalScenes = scriptData.scenes.length;
    const progressPercent = ((sceneId + 1) / totalScenes) * 100;
    progressElement.style.width = `${progressPercent}%`;

    const dialogueBox = document.querySelector('.dialogue-box');
    const dialogueElement = document.getElementById('dialogue-text');
    let displayText = scene.text[stats.language];
    if (stats.completionCount >= 1 && scene.second_playthrough_text) {
        displayText = scene.second_playthrough_text[stats.language];
    }
    console.log(`[showScene] Текст для отображения: ${displayText}`);

    const newBackground = scene.background || 'none';
    const shouldFade = currentBackground !== newBackground || sceneId === scriptData.scenes.length - 1;

    const applyScene = async () => {
        console.log('[applyScene] Применяем сцену');
        currentBackground = await setupBackground(newBackground, stats.language);
        await setupCharacters(scene, stats.language, stats);

        const overlay = createOverlayIfNeeded(sceneId, displayText, scene.choices && scene.choices.some(c => c.timer));
        clearDialogueHandlers(dialogueBox);
        dialogueBox.style.pointerEvents = 'none';

        console.log('[applyScene] Запускаем typeText');
        typeText(displayText, dialogueElement, () => {
            console.log(`[${Date.now()}] Текст сцены ${sceneId} полностью показан`);
            console.log(`[showScene] Проверка: scene.id=${sceneId}, totalScenes=${totalScenes}, nextScene=${scene.nextScene}`);
            dialogueBox.style.pointerEvents = 'auto';
            handleChoices(scene, dialogueBox, overlay);
            handleNextScene(scene, dialogueBox, overlay);
            handleChapterEnd(scene);

            // Проверка на конец главы или ветки
            if (!scene.choices && scene.nextScene === null) {
                console.log(`[showScene] nextScene === null, считаем концом главы`);
                currentChapter++;
                currentScene = 0;
                loadChapter(currentChapter).then(success => {
                    if (success) {
                        console.log(`[showScene] Успешно перешли к главе ${currentChapter}, сцена ${currentScene}`);
                        showScene(currentScene);
                    } else {
                        console.warn(`[showScene] Не удалось загрузить главу ${currentChapter}`);
                        showStartScreen();
                    }
                });
            } else if (!scene.choices && scene.nextScene === undefined) {
                console.warn(`[showScene] Нет choices/nextScene для сцены ${sceneId}, но nextScene не null`);
                if (sceneId === scriptData.scenes.length - 1) {
                    console.log(`[showScene] Это последняя сцена, завершаем главу`);
                    currentChapter++;
                    currentScene = 0;
                    loadChapter(currentChapter).then(success => {
                        if (success) showScene(currentScene);
                    });
                } else {
                    console.log(`[showScene] Принудительный переход к следующей сцене`);
                    addTapHandler(dialogueBox, () => {
                        if (overlay) overlay.remove();
                        currentScene = sceneId + 1;
                        saveSession();
                        showScene(currentScene);
                    });
                }
            }
        });
    };

    if (shouldFade) {
        fadeOut(() => {
            applyScene();
            fadeIn();
        });
    } else {
        await applyScene();
    }

    if (scene.leadsToEnding) {
        console.log(`Загрузка концовки: ${scene.leadsToEnding}`);
        loadFinals(scene.leadsToEnding);
    }
}


                        function showSceneWithTimer(scene, timeoutMs = 10000) {
    console.log(`[showSceneWithTimer] Показ сцены ${scene.id} с таймером (${timeoutMs}мс)`);

    // Элементы DOM
    const progressElement = document.getElementById('progress');
    const backgroundElement = document.getElementById('background');
    const charLeft = document.getElementById('character-left');
    const charRight = document.getElementById('character-right');
    const dialogueElement = document.getElementById('dialogue-text');
    const dialogueBox = document.querySelector('.dialogue-box');

    // Обновление прогресс-бара
    const totalScenes = scriptData.scenes.length;
    const progressPercent = ((scene.id + 1) / totalScenes) * 100;
    progressElement.style.width = `${progressPercent}%`;

    // Выбор текста в зависимости от прохождения
    let displayText = scene.text[stats.language];
    if (stats.completionCount >= 1 && scene.second_playthrough_text) {
        displayText = scene.second_playthrough_text[stats.language];
    }
    console.log(`[showSceneWithTimer] Текст для отображения: ${displayText}`);

    // Проверка необходимости затухания
    const newBackground = scene.background || 'none';
    const shouldFade = currentBackground !== newBackground || scene.id === scriptData.scenes.length - 1;

    // Основная логика сцены
    const applyScene = async () => {
        console.log('[applyScene] Применяем сцену с таймером');

        // Установка фона
        const bgUrl = newBackground === 'none' ? 'none' : `/heart_at_crossroads/assets/backgrounds/${newBackground}.png`;
        if (bgUrl !== 'none' && !(await checkAssetExists(bgUrl))) {
            console.warn(`Фон ${newBackground}.png не найден`);
            showErrorMessage(stats.language === "ru" ? `Фон ${newBackground} не найден` : `Background ${newBackground} not found`);
        }
        backgroundElement.style.backgroundImage = bgUrl === 'none' ? 'none' : `url('${bgUrl}')`;
        currentBackground = newBackground;

        // Очистка и настройка персонажей
        charLeft.style.backgroundImage = 'none';
        charRight.style.backgroundImage = 'none';
        charLeft.classList.remove('character-speaker', 'character-non-speaker', 'shiver', 'heartbeat');
        charRight.classList.remove('character-speaker', 'character-non-speaker', 'shiver', 'heartbeat');

        const speakerName = scene.speaker ? scene.speaker[stats.language] : '';
        if (scene.characterLeft) {
            const leftChar = scene.characterLeft.includes('${stats.appearance}') 
                ? scene.characterLeft.replace('${stats.appearance}', stats.appearance)
                : scene.characterLeft;
            const leftCharUrl = `/heart_at_crossroads/assets/characters/${leftChar.split('_')[0]}/${leftChar}.png`;
            if (!(await checkAssetExists(leftCharUrl))) {
                console.warn(`Персонаж ${leftChar}.png не найден`);
                showErrorMessage(stats.language === "ru" ? `Персонаж ${leftChar} не найден` : `Character ${leftChar} not found`);
            }
            charLeft.style.backgroundImage = `url('${leftCharUrl}')`;
            charLeft.classList.add(speakerName === "Анна" || speakerName === "Anna" ? 'character-speaker' : 'character-non-speaker');
        }
        if (scene.characterRight) {
            const rightChar = scene.characterRight.includes('${stats.appearance}') 
                ? scene.characterRight.replace('${stats.appearance}', stats.appearance)
                : scene.characterRight;
            const rightCharUrl = `/heart_at_crossroads/assets/characters/${rightChar.split('_')[0]}/${rightChar}.png`;
            if (!(await checkAssetExists(rightCharUrl))) {
                console.warn(`Персонаж ${rightChar}.png не найден`);
                showErrorMessage(stats.language === "ru" ? `Персонаж ${rightChar} не найден` : `Character ${rightChar} not found`);
            }
            charRight.style.backgroundImage = `url('${rightCharUrl}')`;
            charRight.classList.add(speakerName === "Вика" || speakerName === "Vika" ? 'character-speaker' : 'character-non-speaker');
        }

        // Смещение персонажей, если указано
        if (scene.characterLeftOffset) charLeft.style.left = scene.characterLeftOffset;
        if (scene.characterRightOffset) charRight.style.right = scene.characterRightOffset;

        // Очистка старых кнопок и обработчиков
        document.querySelectorAll('.choice-btn').forEach(btn => btn.remove());
        if (dialogueBox.touchHandler) {
            dialogueBox.removeEventListener('touchstart', dialogueBox.touchHandler, { passive: false });
            dialogueBox.removeEventListener('click', dialogueBox.touchHandler);
            dialogueBox.touchHandler = null;
            console.log('[showSceneWithTimer] Очищены старые touchHandler');
        }

        // Создание оверлея для сцены с таймером (ТОЛЬКО showMessengerOverlay)
        let overlay = null;
        if (scene.choices && scene.choices.some(c => c.timer)) {
            overlay = showMessengerOverlay(scene.id); // Используем showMessengerOverlay для сцен с таймером
            console.log(`[showSceneWithTimer] Создан оверлей с таймером для сцены ${scene.id}`);
        }

        // Установка имени спикера
        document.getElementById('speaker-name').textContent = speakerName;

        // Воспроизведение звука и музыки
        if (scene.sound) playSound(scene.sound);
        if (scene.music) playMusic(scene.music);

        // Печать текста и обработка выбора
        typeText(displayText, dialogueElement, () => {
            console.log(`[${Date.now()}] Текст сцены ${scene.id} полностью показан`);
            dialogueBox.style.pointerEvents = 'auto'; // Включаем кликабельность

            // Создание кнопок выбора
            scene.choices.forEach(choice => {
                const btn = createChoiceButton(choice);
                if (choice.condition && !checkCondition(choice.condition)) {
                    btn.style.display = 'none';
                } else if (choice.cost && stats.diamonds < choice.cost) {
                    btn.disabled = true;
                } else {
                    const handleChoice = (e) => {
                        e.preventDefault();
                        console.log(`[${Date.now()}] Выбор сделан: ${choice.id}`);
                        if (choice.cost) stats.diamonds -= choice.cost;
                        updateDiamondsDisplay();
                        saveChoice(choice.id, choice.effects, choice.memoryTag);
                        if (choice.effects) showChoiceEffects(choice.effects);
                        clearInterval(countdownInterval);
                        clearTimeout(timer);
                        if (overlay) overlay.remove();
                        document.getElementById('timer-countdown')?.remove();
                        if (tickSound) tickSound.pause();
                        if (choice.nextScene !== undefined) {
                            currentScene = choice.nextScene;
                            saveSession();
                            showScene(currentScene);
                        } else if (choice.nextChapter) {
                            currentChapter = choice.nextChapter;
                            currentScene = 0;
                            loadChapter(currentChapter).then(() => showScene(currentScene));
                        }
                    };
                    btn.addEventListener('touchstart', handleChoice, { passive: false });
                    btn.addEventListener('click', handleChoice);
                }
                dialogueBox.appendChild(btn);
            });

            // Настройка таймера
            const timerDuration = scene.choices.find(c => c.timer)?.timer * 1000 || timeoutMs;
            let timeLeft = timerDuration / 1000;

            const countdownElement = document.createElement('div');
            countdownElement.id = 'timer-countdown';
            countdownElement.textContent = timeLeft;
            document.getElementById('game-container').appendChild(countdownElement);

            // Звук тикающего таймера
            const tickSound = new Audio('/heart_at_crossroads/assets/sounds/sfx_tick.mp3');
            tickSound.loop = false;
            tickSound.play().catch(err => {
                console.warn('Ошибка воспроизведения sfx_tick:', err);
                showErrorMessage(stats.language === "ru" ? 'Звук sfx_tick.mp3 не найден' : 'Sound sfx_tick.mp3 not found');
            });

            // Обновление таймера каждую секунду
            const countdownInterval = setInterval(() => {
                timeLeft--;
                countdownElement.textContent = timeLeft;
                if (overlay) {
                    overlay.classList.add('flash-svg');
                    setTimeout(() => overlay.classList.remove('flash-svg'), 500);
                }
                if ('vibrate' in navigator) navigator.vibrate(200);
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    tickSound.pause();
                }
            }, 1000);

            // Действие по истечении таймера
            const timer = setTimeout(() => {
                const defaultChoice = scene.choices.find(c => c.id === 'ignore');
                console.log(`[${Date.now()}] Таймер истёк, выбор по умолчанию: ${defaultChoice?.id || 'не найден'}`);
                clearInterval(countdownInterval);
                if (overlay) overlay.remove();
                document.getElementById('timer-countdown')?.remove();
                tickSound.pause();
                if (defaultChoice && defaultChoice.nextScene !== undefined) {
                    currentScene = defaultChoice.nextScene;
                    saveSession();
                    showScene(currentScene);
                } else if (scene.id === scriptData.scenes.length - 1) {
                    currentChapter++;
                    currentScene = 0;
                    loadChapter(currentChapter).then(success => {
                        if (success) showScene(currentScene);
                    });
                } else {
                    console.warn('Нет сцены по умолчанию для таймера!');
                }
            }, timerDuration);
        });
    };

    // Применение сцены с эффектом затухания, если нужно
    if (shouldFade) {
        fadeOut(() => {
            applyScene();
            fadeIn();
        });
    } else {
        applyScene();
    }

    // Загрузка концовки, если есть
    if (scene.leadsToEnding) {
        console.log(`Загрузка концовки: ${scene.leadsToEnding}`);
        loadFinals(scene.leadsToEnding);
    }
}

        function showPremiumGallery() {
    console.log('showPremiumGallery вызван, stats.memories:', stats.memories);
    if (!window.gsap) {
        console.error("GSAP не найден, fallback на простую галерею.");
        return showSimpleGallery();
    }

    const isRussian = stats.language === "ru";
    const fontFamily = isRussian ? 'GoodVibesCyr, cursive' : 'GreatVibes, cursive';
    const galleryContainer = document.getElementById('gallery-container');
    const startScreen = document.getElementById('start-screen');
    
    // Отключаем прокрутку страницы
    document.body.style.overflow = 'hidden';
    
    galleryContainer.style.display = 'flex';
    galleryContainer.setAttribute('data-gallery', 'true');
    startScreen.style.display = 'none';

    galleryContainer.innerHTML = '';

    // Заголовок "Коллекционные карточки"
    const galleryHeader = document.createElement('div');
    galleryHeader.className = 'gallery-header';
    galleryHeader.style.fontFamily = fontFamily;
    galleryHeader.textContent = isRussian ? "Коллекционные карточки" : "Collection Cards";

    // Подзаголовок "Прошлое остается навсегда"
    const subHeader = document.createElement('div');
    subHeader.style.cssText = `
        color: #F5E6C9; font-size: 2rem; text-align: center; 
        margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    `;
    subHeader.style.fontFamily = fontFamily;
    subHeader.textContent = isRussian ? "Прошлое остается навсегда" : "The past remains forever";

    // Надпись "Серия: Романтика 0/4"
    const seriesTitle = document.createElement('div');
    seriesTitle.className = 'series-title';
    seriesTitle.style.cssText = `
        color: #e0c18e; font-size: 1.5rem; margin-bottom: 1rem; 
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); text-align: center;
    `;
    seriesTitle.style.fontFamily = fontFamily;
    const unlockedCount = cardSeries["romance"].cards.filter(card => stats.memories?.includes(card.id)).length;
    seriesTitle.textContent = isRussian 
        ? `Серия: Романтика ${unlockedCount}/4`
        : `Series: Romance ${unlockedCount}/4`;

    // Кнопка переключения серий "Романтика"
    const seriesButton = document.createElement('button');
    seriesButton.style.cssText = `
        background: linear-gradient(to bottom, #8C6F4A, #5A3F2A);
        color: #F5E6C9; border: none; padding: 8px 16px; border-radius: 20px;
        font-weight: bold; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px; cursor: pointer;
    `;
    seriesButton.style.fontFamily = fontFamily;
    seriesButton.textContent = isRussian ? "Романтика" : "Romance";

    // Контейнер для карточек
    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'cards-container';

    // Кнопки переключения
    const prevButton = document.createElement('button');
    prevButton.textContent = '<';
    prevButton.style.cssText = `
        position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
        background: #8C6F4A; color: #F5E6C9; border: none; padding: 10px 15px;
        border-radius: 50%; font-size: 1.5rem; cursor: pointer;
    `;

    const nextButton = document.createElement('button');
    nextButton.textContent = '>';
    nextButton.style.cssText = `
        position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
        background: #8C6F4A; color: #F5E6C9; border: none; padding: 10px 15px;
        border-radius: 50%; font-size: 1.5rem; cursor: pointer;
    `;

    // Кнопка закрытия
    const closeButton = document.createElement('button');
    closeButton.innerHTML = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M18 6L6 18M6 6L18 18" stroke="#e0c18e" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
    closeButton.style.cssText = `
        position: absolute; top: 1rem; right: 1rem; background: transparent;
        border: none; color: #e0c18e; font-size: 1.5rem; cursor: pointer;
        opacity: 0; width: 40px; height: 40px; display: flex;
        align-items: center; justify-content: center; border-radius: 50%;
        transition: background 0.3s;
    `;
    closeButton.onmouseover = () => closeButton.style.background = 'rgba(224, 193, 142, 0.2)';
    closeButton.onmouseout = () => closeButton.style.background = 'transparent';

    // Сборка элементов
    galleryContainer.appendChild(galleryHeader);
    galleryContainer.appendChild(subHeader);
    galleryContainer.appendChild(seriesTitle);
    galleryContainer.appendChild(seriesButton);
    galleryContainer.appendChild(prevButton);
    galleryContainer.appendChild(nextButton);
    galleryContainer.appendChild(cardsContainer);
    galleryContainer.appendChild(closeButton);

    // Звуки
    const clickSound = new Audio('/heart_at_crossroads/assets/sounds/sfx_camera_click.mp3');
    clickSound.load();

    // Анимация появления
    gsap.to(galleryContainer, {
        opacity: 1,
        duration: 0.5,
        ease: "power2.out",
        onComplete: () => {
            gsap.to(galleryHeader, { opacity: 1, y: 0, duration: 0.8, ease: "back.out(1.7)" });
            gsap.to(subHeader, { opacity: 1, y: 0, duration: 0.8, delay: 0.1, ease: "back.out(1.7)" });
            gsap.to(seriesTitle, { opacity: 1, y: 0, duration: 0.8, delay: 0.2, ease: "back.out(1.7)" });
            gsap.to(seriesButton, { opacity: 1, duration: 0.8, delay: 0.3, ease: "power2.out" });
            gsap.to(prevButton, { opacity: 1, duration: 0.5, delay: 0.4, ease: "power2.out" });
            gsap.to(nextButton, { opacity: 1, duration: 0.5, delay: 0.4, ease: "power2.out" });
            gsap.to(closeButton, { opacity: 1, duration: 0.5, delay: 0.4, ease: "power2.out" });
            switchSeries('romance', cardsContainer, clickSound, isRussian);
        }
    });

    // Логика переключения карточек
    let currentFrontIndex = 0;
    const cardCount = cardSeries['romance'].cards.length;

    function updateCards() {
        cardSeries['romance'].cards.forEach((card, index) => {
            const cardElement = cardsContainer.querySelector(`[data-card-id="${card.id}"]`);
            const relativeIndex = (index - currentFrontIndex + cardCount) % cardCount;
            const zStep = 150;
            const angleStep = 15;
            const screenWidth = window.innerWidth;
            const cardWidth = 250;
            const maxVisibleWidth = Math.min(screenWidth - 20, 500);

            gsap.to(cardElement, {
                z: relativeIndex * zStep,
                rotateY: relativeIndex * angleStep,
                opacity: 1 - relativeIndex * 0.2,
                scale: Math.min(1 - relativeIndex * 0.05, maxVisibleWidth / cardWidth),
                zIndex: cardCount - relativeIndex,
                duration: 0.8,
                ease: "power2.inOut"
            });
        });
    }

    // Обработчики событий
    addEventListeners(seriesButton, ['click', 'touchstart'], () => {
        switchSeries('romance', cardsContainer, clickSound, isRussian);
        clickSound.play().catch(err => console.warn("Ошибка звука:", err));
    });

    addEventListeners(prevButton, ['click', 'touchstart'], () => {
        currentFrontIndex = (currentFrontIndex - 1 + cardCount) % cardCount;
        updateCards();
        clickSound.play().catch(err => console.warn("Ошибка звука:", err));
    });

    addEventListeners(nextButton, ['click', 'touchstart'], () => {
        currentFrontIndex = (currentFrontIndex + 1) % cardCount;
        updateCards();
        clickSound.play().catch(err => console.warn("Ошибка звука:", err));
    });

    addEventListeners(closeButton, ['click', 'touchstart'], () => {
        document.body.style.overflow = ''; // Восстанавливаем прокрутку
        closeGallery();
        clickSound.play().catch(err => console.warn("Ошибка звука:", err));
    });
}


   function switchSeries(seriesKey, cardsContainer, clickSound, isRussian) {
    console.log('switchSeries вызван для:', seriesKey);
    const series = cardSeries[seriesKey];
    if (!series) return;

    cardsContainer.innerHTML = '';
    const cardCount = series.cards.length;
    const zStep = 150; // Увеличенное расстояние для удобного тапа
    const angleStep = 15; // Увеличенный угол для видимости
    const screenWidth = window.innerWidth;
    const cardWidth = 250; // Уменьшенная ширина карточек
    const maxVisibleWidth = Math.min(screenWidth - 20, 500); // Ограничение по ширине экрана

    series.cards.forEach((card, index) => {
        const cardElement = createCardElement(card, seriesKey, cardsContainer, clickSound, isRussian);
        const zPosition = index * zStep;
        const rotateY = index * angleStep;

        gsap.set(cardElement, {
            z: zPosition,
            rotateY: rotateY,
            opacity: 1 - index * 0.2,
            scale: Math.min(1 - index * 0.05, maxVisibleWidth / cardWidth),
        });

        cardElement.style.zIndex = cardCount - index;
        cardsContainer.appendChild(cardElement);

        addEventListeners(cardElement, ['click', 'touchstart'], (e) => {
            e.preventDefault();
            if (stats.memories?.includes(card.id)) {
                showCardDetail(card, isRussian, clickSound);
            }
            // Заблокированные карточки можно листать кнопками, но не открывать
        });
    });
}

function createCardElement(card, seriesKey, cardsContainer, clickSound, isRussian) {
    const isUnlocked = stats.memories?.includes(card.id);
    const cardElement = document.createElement('div');
    cardElement.className = 'premium-card';
    cardElement.dataset.cardId = card.id;
    if (!isUnlocked) cardElement.classList.add('locked');

    if (isUnlocked) {
        const cardImg = document.createElement('img');
        cardImg.src = `/heart_at_crossroads/assets/memories/${card.id}.png`;
        cardImg.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        cardElement.appendChild(cardImg);

        const shineEffect = document.createElement('div');
        shineEffect.className = 'card-shine-effect';
        cardElement.appendChild(shineEffect);

        const cardName = document.createElement('div');
        cardName.className = 'card-name';
        cardName.style.fontFamily = isRussian ? 'GoodVibesCyr, cursive' : 'GreatVibes, cursive';
        cardName.textContent = isRussian ? card.name : card.nameEn;
        cardElement.appendChild(cardName);
    } else {
        const lockImg = document.createElement('img');
        lockImg.src = '/heart_at_crossroads/assets/memories/card_locked.png';
        lockImg.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        cardElement.appendChild(lockImg);

        const unlockText = document.createElement('div');
        unlockText.className = 'unlock-text';
        unlockText.style.fontFamily = isRussian ? 'GoodVibesCyr, cursive' : 'GreatVibes, cursive';
        const diamondIcon = `<img src="/heart_at_crossroads/assets/ui/diamonds.png" style="width: 16px; height: 16px; vertical-align: middle;">`;
        unlockText.innerHTML = isRussian 
            ? `Разблокировка: ${card.unlock} ${diamondIcon}` 
            : `Unlock: ${card.unlockEn} ${diamondIcon}`;
        cardElement.appendChild(unlockText);

        const unlockButton = document.createElement('button');
        unlockButton.className = 'card-unlock-button';
        unlockButton.style.fontFamily = isRussian ? 'GoodVibesCyr, cursive' : 'GreatVibes, cursive';
        unlockButton.textContent = isRussian ? "Разблокировать" : "Unlock";
        unlockButton.onclick = (e) => {
            e.stopPropagation(); // Предотвращаем срабатывание перелистывания
            unlockCard(card, cardsContainer, clickSound, isRussian);
        };
        cardElement.appendChild(unlockButton);
    }

    return cardElement;
}

    function unlockCard(card, cardsContainer, clickSound, isRussian) {
    const unlockCost = card.unlock; // Количество бриллиантов для разблокировки
    const hasEnoughDiamonds = stats.diamonds >= unlockCost; // Предполагаем, что stats.diamonds хранит бриллианты
    const isSecondPlaythrough = stats.playthroughs > 1; // Предполагаем, что stats.playthroughs отслеживает прохождения

    if (hasEnoughDiamonds || isSecondPlaythrough) {
        if (hasEnoughDiamonds) {
            stats.diamonds -= unlockCost; // Списываем бриллианты
            console.log(`Потрачено ${unlockCost} бриллиантов`);
        } else {
            console.log("Разблокировано за второе прохождение");
        }

        // Добавляем карточку в разблокированные
        if (!stats.memories) stats.memories = [];
        stats.memories.push(card.id);

        // Обновляем карточку в галерее
        const cardElement = cardsContainer.querySelector(`[data-card-id="${card.id}"]`);
        cardElement.classList.remove('locked');
        cardElement.innerHTML = ''; // Очищаем содержимое

        const cardImg = document.createElement('img');
        cardImg.src = `/heart_at_crossroads/assets/memories/${card.id}.png`;
        cardImg.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        cardElement.appendChild(cardImg);

        const shineEffect = document.createElement('div');
        shineEffect.className = 'card-shine-effect';
        cardElement.appendChild(shineEffect);

        const cardName = document.createElement('div');
        cardName.className = 'card-name';
        cardName.style.fontFamily = isRussian ? 'GoodVibesCyr, cursive' : 'GreatVibes, cursive';
        cardName.textContent = isRussian ? card.name : card.nameEn;
        cardElement.appendChild(cardName);

        // Проигрываем звук разблокировки
        const unlockSound = new Audio('/heart_at_crossroads/assets/sounds/sfx_card_unlock.mp3');
        unlockSound.play().catch(err => console.warn("Ошибка звука:", err));
        clickSound.play().catch(err => console.warn("Ошибка звука:", err));
    } else {
        console.log("Недостаточно бриллиантов или не второе прохождение");
        // Здесь можно добавить уведомление для пользователя
    }
}
    function showUnlockNotification(card, isRussian) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(to bottom, #D9C2A7, #BFA78A); border: 2px dashed #8C6F4A;
            border-radius: 10px; padding: 20px; color: #333; text-align: center;
            z-index: 2000; max-width: 300px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            opacity: 0;
        `;
        notification.innerHTML = `
            <div style="font-size: 1.5rem; color: #8C6F4A; margin-bottom: 10px; font-family: ${isRussian ? 'GoodVibesCyr' : 'GreatVibes'}, cursive;">
                ${isRussian ? 'Карта разблокирована!' : 'Card Unlocked!'}
            </div>
            <div style="font-size: 1.2rem; margin-bottom: 15px; font-family: ${isRussian ? 'GoodVibesCyr' : 'GreatVibes'}, cursive;">
                ${isRussian ? card.name : card.nameEn}
            </div>
            <img src="/heart_at_crossroads/assets/memories/${card.id}.png" alt="Card" style="width: 100%; border-radius: 5px; margin-bottom: 15px;">
            <button style="
                background: linear-gradient(to bottom, #8C6F4A, #5A3F2A);
                color: #F5E6C9; border: none; padding: 10px 20px; border-radius: 20px;
                font-weight: bold; cursor: pointer; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
                font-family: ${isRussian ? 'GoodVibesCyr' : 'GreatVibes'}, cursive;
            ">${isRussian ? 'Супер!' : 'Awesome!'}</button>
        `;
        document.body.appendChild(notification);

        gsap.to(notification, {
            opacity: 1,
            duration: 0.5,
            ease: "power2.out",
            onComplete: () => {
                const closeBtn = notification.querySelector('button');
                closeBtn.onclick = () => {
                    gsap.to(notification, {
                        opacity: 0,
                        duration: 0.3,
                        ease: "power2.in",
                        onComplete: () => document.body.removeChild(notification)
                    });
                };
            }
        });
    }

    function showCardDetail(card, isRussian, clickSound) {
        const detailContainer = document.createElement('div');
        detailContainer.className = 'card-detail';
        detailContainer.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 350px; height: 350px; background: linear-gradient(to bottom, #F5E6C9, #E6D7A8);
            border-radius: 5px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7); z-index: 3000;
        `;

        const img = document.createElement('img');
        img.src = `/heart_at_crossroads/assets/memories/${card.id}.png`;
        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        detailContainer.appendChild(img);

        const name = document.createElement('div');
        name.style.fontFamily = isRussian ? 'GoodVibesCyr, cursive' : 'GreatVibes, cursive';
        name.textContent = isRussian ? card.name : card.nameEn;
        name.style.cssText = 'position: absolute; bottom: 0; width: 100%; text-align: center; padding: 5px; color: #333; font-size: 1.2rem;';
        detailContainer.appendChild(name);

        document.body.appendChild(detailContainer);
        document.getElementById('gallery-container').style.background = 'rgba(0, 0, 0, 0.8)';

        addEventListeners(detailContainer, ['click', 'touchstart'], () => {
            document.body.removeChild(detailContainer);
            document.getElementById('gallery-container').style.background = "url('/heart_at_crossroads/assets/images/shoebox_texture.png') center / cover no-repeat";
            clickSound.play().catch(err => console.warn("Ошибка звука:", err));
        });
    }
	    
         function closeGallery() {
    console.log('closeGallery вызван');
    const galleryContainer = document.getElementById('gallery-container');
    const startScreen = document.getElementById('start-screen');

    if (galleryContainer) {
        gsap.to(galleryContainer, {
            opacity: 0,
            duration: 0.5,
            ease: "power2.in",
            onComplete: () => {
                galleryContainer.innerHTML = ''; // Очищаем содержимое
                galleryContainer.style.display = 'none';
                startScreen.style.display = 'flex'; // Возвращаем стартовый экран
                startScreen.style.pointerEvents = 'auto';
                startScreen.style.zIndex = '3000';
            }
        });
    }

    if (startScreen) {
        startScreen.style.display = 'flex';
        startScreen.style.pointerEvents = 'auto';
        startScreen.style.zIndex = '3000';
    }
}


                       function showSimpleGallery() {
            console.log("Показываем простую галерею без GSAP");
            const galleryDiv = document.createElement('div');
            galleryDiv.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                background: rgba(0, 0, 0, 0.9); z-index: 10; overflow-y: auto;
            `;

            const galleryTitle = document.createElement('h2');
            galleryTitle.style.cssText = `
                color: #e0c18e; text-align: center; margin: 20px 0; 
                font-family: ${stats.language === "ru" ? 'GoodVibesCyr' : 'GreatVibes'}, cursive; font-size: 36px;
            `;
            galleryTitle.textContent = stats.language === "ru" ? "Коллекционные карточки" : "Collection Cards";
            galleryDiv.appendChild(galleryTitle);

            if (stats.memories?.length > 0) {
                stats.memories.forEach(memory => {
                    const cardWrapper = document.createElement('div');
                    cardWrapper.style.cssText = 'display: inline-block; margin: 15px; position: relative;';
                    const img = document.createElement('img');
                    img.src = `/heart_at_crossroads/assets/memories/${memory}.png`;
                    img.style.cssText = 'display: block; max-width: 300px; border: 8px solid #e0c18e; border-radius: 5px;';
                    img.onerror = () => {
                        console.warn(`Воспоминание ${memory}.png не найдено`);
                        cardWrapper.remove();
                    };
                    cardWrapper.appendChild(img);
                    galleryDiv.appendChild(cardWrapper);
                });
            } else {
                const noCardsMsg = document.createElement('p');
                noCardsMsg.style.cssText = 'color: #e0c18e; text-align: center; margin: 50px 0;';
                noCardsMsg.textContent = stats.language === "ru" ? "У вас пока нет открытых карточек" : "You don't have any unlocked cards yet";
                galleryDiv.appendChild(noCardsMsg);
            }

            const closeBtn = document.createElement('button');
            closeBtn.textContent = stats.language === "ru" ? "Закрыть" : "Close";
            closeBtn.style.cssText = `
                position: fixed; top: 10px; right: 10px; background: #333; 
                color: #e0c18e; border: 1px solid #e0c18e; padding: 5px 15px; cursor: pointer;
            `;
            closeBtn.onclick = () => galleryDiv.remove();
            galleryDiv.appendChild(closeBtn);
            document.body.appendChild(galleryDiv);
        }



        async function loadFinals(endingId) {
            const response = await fetch('/heart_at_crossroads/assets/data/finals.json');
            const finalsData = await response.json();
            const ending = finalsData.endings.find(e => e.id === endingId);
            if (ending && checkRequirements(ending.requirements)) {
                showEnding(ending);
            } else {
                console.warn('Концовка не найдена или требования не выполнены');
                showStartScreen();
            }
        }

        function checkRequirements(requirements) {
            if (!requirements) return true;
            for (let key in requirements) {
                const value = stats[key] || stats.relationships[key.split('.')[1]] || 0;
                const req = requirements[key];
                if (req.startsWith('>')) {
                    const compareValue = req.includes('+') ? 
                        (stats[req.split('+')[0].slice(1)] + stats[req.split('+')[1]]) : 
                        parseInt(req.slice(1));
                    return value > compareValue;
                }
                return value >= parseInt(req);
            }
            return true;
        }

        function showEnding(ending) {
            const scene = ending.scenes[0];
            const backgroundElement = document.getElementById('background');
            const charLeft = document.getElementById('character-left');
            const charRight = document.getElementById('character-right');
            const dialogueElement = document.getElementById('dialogue-text');
            const speakerName = document.getElementById('speaker-name');

            const bgUrl = `/heart_at_crossroads/assets/backgrounds/${scene.background}.png`;
            checkAssetExists(bgUrl).then(exists => {
                if (!exists) {
                    console.warn(`Фон ${scene.background}.png не найден`);
                    showErrorMessage(stats.language === "ru" ? `Фон ${scene.background} не найден` : `Background ${scene.background} not found`);
                }
                backgroundElement.style.backgroundImage = `url('${bgUrl}')`;
            });

            if (scene.characterLeft) {
                const leftCharUrl = `/heart_at_crossroads/assets/characters/${scene.characterLeft.split('_')[0]}/${scene.characterLeft}.png`;
                checkAssetExists(leftCharUrl).then(exists => {
                    if (!exists) {
                        console.warn(`Персонаж ${scene.characterLeft}.png не найден`);
                        showErrorMessage(stats.language === "ru" ? `Персонаж ${scene.characterLeft} не найден` : `Character ${scene.characterLeft} not found`);
                    }
                    charLeft.style.backgroundImage = `url('${leftCharUrl}')`;
                });
            } else charLeft.style.backgroundImage = 'none';

            if (scene.characterRight) {
                const rightCharUrl = `/heart_at_crossroads/assets/characters/${scene.characterRight.split('_')[0]}/${scene.characterRight}.png`;
                checkAssetExists(rightCharUrl).then(exists => {
                    if (!exists) {
                        console.warn(`Персонаж ${scene.characterRight}.png не найден`);
                        showErrorMessage(stats.language === "ru" ? `Персонаж ${scene.characterRight} не найден` : `Character ${scene.characterRight} not found`);
                    }
                    charRight.style.backgroundImage = `url('${rightCharUrl}')`;
                });
            } else charRight.style.backgroundImage = 'none';

            speakerName.textContent = scene.speaker[stats.language];
            typeText(stats.completionCount >= 1 && scene.second_playthrough_text ? 
                scene.second_playthrough_text[stats.language] : scene.text[stats.language], 
                dialogueElement, () => {
                    showEpilogue(ending.epilogue[stats.language]);
                });

            if (scene.sound) playSound(scene.sound);
            if (scene.music) playMusic(scene.music);
        }

        function showEpilogue(epilogueText) {
            const epilogueDiv = document.createElement('div');
            epilogueDiv.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); color: white; display: flex; justify-content: center; align-items: center; text-align: center; padding: 20px; z-index: 10;';
            epilogueDiv.textContent = epilogueText;
            document.body.appendChild(epilogueDiv);
            setTimeout(() => {
                epilogueDiv.remove();
                stats.completionCount++;
                saveSession();
                showStartScreen();
            }, 5000);
        }



     
function checkCondition(condition) {
    if (!condition) return true;
    const [key, operator, value] = condition.split(' ');
    const statValue = stats[key] || stats.relationships[key] || 0;
    const compareValue = parseInt(value);
    switch (operator) {
        case '>': return statValue > compareValue;
        case '<': return statValue < compareValue;
        case '>=': return statValue >= compareValue;
        case '<=': return statValue <= compareValue;
        case '==': return statValue == compareValue;
        case '!=': return statValue != compareValue;
        default: return false;
    }
}

 function typeText(text, element, callback) {
    if (isTyping) {
        console.log(`[${Date.now()}] typeText уже идёт, пропускаем`);
        return;
    }
    const callId = Date.now();
    console.log(`[${callId}] Начинаем печатать текст: "${text}"`);
    isTyping = true;
    console.log(`[${callId}] isTyping установлен в true`);
    element.textContent = '';
    if (element.typeTimer) {
        console.log(`[${callId}] Очищаем старый таймер`);
        clearTimeout(element.typeTimer);
    }
    const parts = text.split('||').map(part => part.trim()).filter(part => part.length > 0);
    console.log(`[${callId}] Частей текста: ${parts.length}, parts: ${JSON.stringify(parts)}`);
    let partIndex = 0;
    let i = 0;
    const speed = 50;
    const dialogueBox = document.querySelector('.dialogue-box');
    if (!dialogueBox) console.error(`[${callId}] dialogueBox не найден!`);

    function clearHandlers() {
        if (dialogueBox) {
            if (dialogueBox.tapHandler) {
                dialogueBox.removeEventListener('touchstart', dialogueBox.tapHandler, { passive: false });
                dialogueBox.removeEventListener('click', dialogueBox.tapHandler);
                console.log(`[${callId}] Очистка обработчиков тапов (tapHandler)`);
                dialogueBox.tapHandler = null;
            }
            if (dialogueBox.touchHandler) {
                dialogueBox.removeEventListener('touchstart', dialogueBox.touchHandler, { passive: false });
                dialogueBox.removeEventListener('click', dialogueBox.touchHandler);
                console.log(`[${callId}] Очистка обработчиков тапов (touchHandler)`);
                dialogueBox.touchHandler = null;
            }
        } else {
            console.error(`[${callId}] dialogueBox не найден при очистке обработчиков`);
        }
    }
    clearHandlers();

    function type() {
        console.log(`[${callId}] type(): partIndex=${partIndex}, i=${i}, parts.length=${parts.length}`);
        if (partIndex >= parts.length) {
            isTyping = false;
            console.log(`[${callId}] isTyping сброшен в false (все части готовы)`);
            clearHandlers();
            console.log(`[${callId}] Все части напечатаны, вызываем callback`);
            if (callback) {
                console.log(`[${callId}] Callback существует, запускаем`);
                callback();
            } else {
                console.log(`[${callId}] Callback не передан`);
            }
            return;
        }
        if (i < parts[partIndex].length) {
            element.textContent += parts[partIndex].charAt(i);
            i++;
            console.log(`[${callId}] Печатаем символ ${i} части ${partIndex + 1}: "${parts[partIndex]}"`);
            element.typeTimer = setTimeout(type, speed);
        } else {
            isTyping = false;
            console.log(`[${callId}] isTyping сброшен в false (часть ${partIndex + 1} готова)`);
            console.log(`[${callId}] Завершена часть ${partIndex + 1} из ${parts.length}`);
            if (partIndex === parts.length - 1) {
                console.log(`[${callId}] Последняя часть завершена, вызываем callback`);
                clearHandlers();
                if (callback) {
                    console.log(`[${callId}] Callback существует, запускаем`);
                    callback();
                } else {
                    console.log(`[${callId}] Callback не передан`);
                }
            } else {
                // Переход к следующей части
                console.log(`[${callId}] Переход к части ${partIndex + 2}`);
                partIndex++;
                i = 0;
                element.textContent = '';
                isTyping = true;
                type();
            }
        }
    }

    function handleTap(e) {
        e.preventDefault();
        e.stopPropagation();
        console.log(`[${callId}] Тап, isTyping: ${isTyping}, partIndex=${partIndex}`);
        if (isTyping) {
            console.log(`[${callId}] Пропускаем анимацию части ${partIndex + 1}`);
            clearTimeout(element.typeTimer);
            element.textContent = parts[partIndex];
            i = parts[partIndex].length;
            isTyping = false;
            console.log(`[${callId}] isTyping сброшен в false (анимация пропущена)`);
            if (partIndex === parts.length - 1) {
                console.log(`[${callId}] Пропущена последняя часть, вызываем callback`);
                clearHandlers();
                if (callback) {
                    console.log(`[${callId}] Запускаем callback после пропуска`);
                    callback();
                } else {
                    console.log(`[${callId}] Callback не передан после пропуска`);
                }
            } else {
                console.log(`[${callId}] Переход к части ${partIndex + 2} после пропуска`);
                partIndex++;
                i = 0;
                element.textContent = '';
                isTyping = true;
                type();
            }
        } else if (partIndex < parts.length - 1) {
            console.log(`[${callId}] Переход к части ${partIndex + 2}`);
            partIndex++;
            i = 0;
            element.textContent = '';
            isTyping = true;
            console.log(`[${callId}] isTyping установлен в true (следующая часть)`);
            type();
        } else {
            console.log(`[${callId}] Все части показаны, вызываем callback`);
            isTyping = false;
            console.log(`[${callId}] isTyping сброшен в false (финальный тап)`);
            clearHandlers();
            if (callback) {
                console.log(`[${callId}] Запускаем callback после финального тапа`);
                callback();
            } else {
                console.log(`[${callId}] Callback не передан после финального тапа`);
            }
        }
    }

    if (dialogueBox) {
        dialogueBox.tapHandler = handleTap;
        dialogueBox.addEventListener('touchstart', handleTap, { passive: false });
        dialogueBox.addEventListener('click', handleTap);
        console.log(`[${callId}] Обработчик тапов установлен`);
        dialogueBox.style.pointerEvents = 'auto'; // Убедимся, что элемент кликабелен
    } else {
        console.error(`[${callId}] Не удалось установить обработчик тапов: dialogueBox отсутствует`);
    }

    type();
}


        
function fadeOut(callback) {
    const elements = [
        document.getElementById('background'),
        document.getElementById('character-left'),
        document.getElementById('character-right'),
        document.querySelector('.dialogue-box')
    ];
    elements.forEach(el => el.classList.add('fade-out'));
    setTimeout(() => {
        elements.forEach(el => el.classList.remove('fade-out'));
        if (callback) callback();
    }, 1000);
}

function fadeIn() {
    const elements = [
        document.getElementById('background'),
        document.getElementById('character-left'),
        document.getElementById('character-right'),
        document.querySelector('.dialogue-box')
    ];
    elements.forEach(el => {
        el.style.opacity = '0';
        el.style.transition = 'opacity 1s ease';
        setTimeout(() => el.style.opacity = '1', 10);
    });
}

function showChoiceEffects(effects) {
    const feedback = document.createElement('img');
    feedback.className = 'choice-feedback';
    if (effects.crown) feedback.src = '/heart_at_crossroads/assets/ui/crown.png';
    else if (effects.heart) feedback.src = '/heart_at_crossroads/assets/ui/heart.png';
    else if (effects.leaf) feedback.src = '/heart_at_crossroads/assets/ui/leaf.png';
    else return;
    document.getElementById('game-container').appendChild(feedback);
    setTimeout(() => feedback.remove(), 3000);
}

</script>
